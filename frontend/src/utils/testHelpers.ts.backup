import { render, RenderOptions } from '@testing-library/react'
import { ReactElement } from 'react'
import { BrowserRouter } from 'react-router-dom'
import { AuthProvider } from '../contexts/AuthContext'
import { NavigationProvider } from '../contexts/NavigationContext'
import { vi } from 'vitest'

/**
 * 自訂渲染函數，包含必要的 Provider
 */
const AllProviders = ({ children }: { children: React.ReactNode }) => {
  return (
    <BrowserRouter>
      <AuthProvider>
        <NavigationProvider>
          {children}
        </NavigationProvider>
      </AuthProvider>
    </BrowserRouter>
  )
}

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllProviders, ...options })

export * from '@testing-library/react'
export { customRender as render }

/**
 * 模擬導航函數
 */
export const mockNavigate = vi.fn()

/**
 * 模擬 React Router hooks
 */
export const mockUseNavigate = () => mockNavigate
export const mockUseParams = (params: Record<string, string>) => () => params
export const mockUseLocation = (location: Partial<Location>) => () => ({
  pathname: '/',
  search: '',
  hash: '',
  state: null,
  key: 'default',
  ...location
})

/**
 * 清理所有 mock
 */
export const clearAllMocks = () => {
  vi.clearAllMocks()
  mockNavigate.mockClear()
}

/**
 * 等待非同步操作完成
 */
export const waitForAsync = (ms: number = 0) =>
  new Promise(resolve => setTimeout(resolve, ms))

/**
 * 模擬 API 延遲
 */
export const mockApiDelay = (ms: number = 500) =>
  new Promise(resolve => setTimeout(resolve, ms))

/**
 * 模擬 API 錯誤
 */
export const mockApiError = (message: string, status: number = 500) => {
  const error = new Error(message) as any
  error.status = status
  return Promise.reject(error)
}

/**
 * 創建測試用的提交記錄
 */
export const createMockSubmission = (overrides = {}) => ({
  id: 'test_001',
  userId: 'user_001',
  userName: '測試用戶',
  userDepartment: '測試部門',
  categoryId: 'diesel',
  categoryName: '柴油',
  scope: 1 as const,
  status: 'submitted' as const,
  submissionDate: '2024-03-15',
  amount: 100,
  unit: '公升',
  co2Emission: 250,
  priority: 'medium' as const,
  ...overrides
})

/**
 * 創建測試用的用戶
 */
export const createMockUser = (overrides = {}) => ({
  id: 'user_001',
  name: '測試用戶',
  email: 'test@example.com',
  department: '測試部門',
  status: 'submitted' as const,
  submissionDate: '2024-03-15',
  lastActivity: '2024-03-20',
  entries: 5,
  avatar: '👨‍💻',
  ...overrides
})

/**
 * 創建測試用的能源類別
 */
export const createMockEnergyCategory = (overrides = {}) => ({
  id: 'diesel',
  name: '柴油',
  scope: 1 as const,
  ...overrides
})

/**
 * 模擬鍵盤事件
 */
export const createKeyboardEvent = (key: string, options = {}) => {
  return new KeyboardEvent('keydown', {
    key,
    code: key,
    bubbles: true,
    cancelable: true,
    ...options
  })
}

/**
 * 模擬滑鼠事件
 */
export const createMouseEvent = (type: string, options = {}) => {
  return new MouseEvent(type, {
    bubbles: true,
    cancelable: true,
    ...options
  })
}

/**
 * 檢查元素是否可見
 */
export const isElementVisible = (element: HTMLElement) => {
  const style = window.getComputedStyle(element)
  return style.display !== 'none' &&
         style.visibility !== 'hidden' &&
         style.opacity !== '0'
}

/**
 * 等待元素出現
 */
export const waitForElement = async (
  querySelector: () => HTMLElement | null,
  timeout: number = 5000
): Promise<HTMLElement> => {
  const start = Date.now()

  return new Promise((resolve, reject) => {
    const check = () => {
      const element = querySelector()
      if (element) {
        resolve(element)
      } else if (Date.now() - start > timeout) {
        reject(new Error('Element not found within timeout'))
      } else {
        setTimeout(check, 100)
      }
    }
    check()
  })
}

/**
 * 測試錯誤邊界
 */
export const ThrowError = ({ error }: { error: Error }) => {
  throw error
}

/**
 * 模擬表單資料
 */
export const createMockFormData = (overrides = {}) => ({
  name: '測試用戶',
  email: 'test@example.com',
  password: 'password123',
  company: '測試公司',
  department: '測試部門',
  targetYear: 2024,
  energyCategories: ['diesel', 'electricity_bill'],
  isActive: true,
  ...overrides
})

/**
 * 模擬本地儲存
 */
export const mockLocalStorage = (() => {
  let store: Record<string, string> = {}

  return {
    getItem: vi.fn((key: string) => store[key] || null),
    setItem: vi.fn((key: string, value: string) => {
      store[key] = value.toString()
    }),
    removeItem: vi.fn((key: string) => {
      delete store[key]
    }),
    clear: vi.fn(() => {
      store = {}
    }),
    key: vi.fn((index: number) => {
      const keys = Object.keys(store)
      return keys[index] || null
    }),
    get length() {
      return Object.keys(store).length
    }
  }
})()

// 在測試環境中替換 localStorage
Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage
})

/**
 * 模擬 window.confirm
 */
export const mockConfirm = vi.fn()
Object.defineProperty(window, 'confirm', { value: mockConfirm })

/**
 * 模擬 window.alert
 */
export const mockAlert = vi.fn()
Object.defineProperty(window, 'alert', { value: mockAlert })

/**
 * 重置所有 window mock
 */
export const resetWindowMocks = () => {
  mockConfirm.mockReset()
  mockAlert.mockReset()
}